<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Свалка текста</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: monospace;
    background: black;
    color: white;
  }
  #textContainer {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    font-size: 20px;
    line-height: 1.2;
  }
</style>
</head>
<body>

<div id="textContainer">
  Вот твой огромный ворох текста который будет сначала виден подряд, как обычный абзац, а потом хаотично упадёт вниз.
</div>

<canvas id="canvas"></canvas>

<script>
const container = document.getElementById('textContainer');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const textNodes = container.innerText.split(/\s+/);

// Получаем позиции слов на странице перед падением
const spanContainer = document.createElement('div');
spanContainer.style.position = 'absolute';
spanContainer.style.visibility = 'hidden';
spanContainer.style.whiteSpace = 'pre-wrap';
spanContainer.style.fontSize = '20px';
spanContainer.style.fontFamily = 'monospace';
spanContainer.style.width = container.offsetWidth + 'px';
document.body.appendChild(spanContainer);

const wordObjects = [];

textNodes.forEach(word => {
  const span = document.createElement('span');
  span.innerText = word + ' ';
  spanContainer.appendChild(span);
  const rect = span.getBoundingClientRect();
  wordObjects.push({
    text: word,
    x: rect.left,
    y: rect.top,
    speed: 50 + Math.random()*100
  });
});

document.body.removeChild(spanContainer);

let startTime = null;
const fallDelay = 4000; // 4 секунды до падения
const maxFallY = canvas.height - 20;

function animate(timestamp) {
  if (!startTime) startTime = timestamp;
  const elapsed = timestamp - startTime;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  ctx.font = '20px monospace';

  wordObjects.forEach(word => {
    if (elapsed > fallDelay) {
      word.y += word.speed * 0.016; // падение
      if (word.y > maxFallY) word.y = maxFallY;
    }
    ctx.fillText(word.text, word.x, word.y);
  });

  requestAnimationFrame(animate);
}

// прячем исходный блок через 4 секунды
setTimeout(() => { container.style.display = 'none'; }, fallDelay);

requestAnimationFrame(animate);
</script>
</body>
</html>
